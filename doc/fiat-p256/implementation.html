<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>implementation (fiat-p256.implementation)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="index.html">Up</a> – <a href="index.html">fiat-p256</a> &#x00BB; implementation</nav><nav class="toc"><ul><li><a href="#implementation">Implementation</a><ul><li><a href="#field-operations">Field operations</a></li><li><a href="#point-operations">Point operations</a></li><li><a href="#scalar-multiplication">Scalar multiplication</a></li><li><a href="#key-exchange">Key exchange</a></li></ul></li></ul></nav></header><h2 id="implementation"><a href="#implementation" class="anchor"></a>Implementation</h2><p>The goal of this document is to describe how the library is implemented.</p><h3 id="field-operations"><a href="#field-operations" class="anchor"></a>Field operations</h3><p>These are implemented in <code>Field_element</code>, which is a binding over <code>p256_{32,64}.h</code>. These are files extracted from Coq code in <a href="https://github.com/mit-plv/fiat-crypto">this repository</a>.</p><p>This module uses <a href="https://en.wikipedia.org/wiki/Montgomery_modular_multiplication">Montgomery Modular Multiplication</a>. Instead of storing a number <code>a</code>, operations are done on <code>aR</code> where R = 2<sup>256</sup>.</p><p>It is possible to check that these files correspond to the extracted ones in the upstream repository by running <code>dune build @check_vendors</code>.</p><p>These files are part of the trusted computing base. That is, using this package relies on the fact that they implemented the correct algorithms. To go further, one can re-run the extraction process from Coq sources, see <a href="https://github.com/mirage/fiat/issues/41">#41</a>.</p><h3 id="point-operations"><a href="#point-operations" class="anchor"></a>Point operations</h3><p>Points (see the <code>Point</code> module) are stored using projective coordinates (X : Y : Z):</p><ul><li>Z=0 corresponds to the point at infinity</li><li>for Z≠0, this corresponds to a point with affine coordinates (X/Z<sup>2</sup>, Y/Z<sup>3</sup>)</li></ul><p>Doubling and addition are implemented as C stubs in <code>p256_stubs.c</code> using code that comes from BoringSSL, Google's fork of OpenSSL. Fiat code has been design in part to be included in BoringSSL, so this does not require any particular glue code.</p><p>Some operations are implemented manually, in particular:</p><ul><li>conversion to affine coordinates, as described above. This relies on a field inversion primitive from BoringSSL, that is exposed in <code>Field_element</code>.</li><li>point verification (bound checking and making sure that the equation is satisfied).</li></ul><p>There is no automated way to check that the BoringSSL part is identical to that in the upstream repository (nor to update it).</p><h3 id="scalar-multiplication"><a href="#scalar-multiplication" class="anchor"></a>Scalar multiplication</h3><p>Implemented by hand using the <a href="https://cr.yp.to/bib/2003/joye-ladder.pdf">Montgomery Powering Ladder</a>.</p><p>Instead of branching based on key bits, constant-time selection (as defined in fiat code) is used.</p><p>The following references discuss this algorithm:</p><ul><li><a href="https://cryptojedi.org/peter/data/eccss-20130911b.pdf">Scalar-multiplication algorithms, Peter Schwabe, ECC 2013 Summer School</a></li><li><a href="https://eprint.iacr.org/2017/293.pdf">Montgomery curves and the Montgomery ladder, Daniel J. Bernstein and Tanja Lange</a></li></ul><h3 id="key-exchange"><a href="#key-exchange" class="anchor"></a>Key exchange</h3><p>Key exchange consists in</p><ul><li>validating the public key as described in <a href="https://tools.ietf.org/html/rfc8446#section-4.2.8.2">RFC 8446 §4.2.8.2</a>;</li><li>computing scalar multiplication;</li><li>returning the encoded x coordinate of the result.</li></ul><p>This is implemented by hand and checked against common errors using test vectors from <a href="https://github.com/google/wycheproof">project Wycheproof</a>.</p></div></body></html>